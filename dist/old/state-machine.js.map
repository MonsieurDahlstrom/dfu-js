{"version":3,"sources":["../../src/old/state-machine.js"],"names":["StateMachineStates","NOT_CONFIGURED","IDLE","TRANSFERING","COMPLETE","FAILED","StateMachine","webBluetoothControlPoint","webBluetoothPacketPoint","_state","Object","defineProperty","get","set","value","delegate","undefined","updateStateMachine","configurable","setControlPoint","setPacketPoint","fileTransfers","controlpointCharacteristic","packetCharacteristic","state","webBluetoothCharacteristic","progress","console","error","transfer","push","kill","firmware","Error","sections","section","addTransfer","dat","Command","bin","Data","module","exports","States"],"mappings":"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","file":"state-machine.js","sourcesContent":["// Copyright (c) 2017 Monsieur DahlstrÃ¶m Ltd\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nimport queue from 'async/queue'\nimport {Firmware} from './firmware'\nimport {Transfer, TransferWorker, CurrentTransfer, TransferObjectType} from './dfu'\n\n/**\nThe states a DFU StateMachine can have:\n  - NOT_CONFIGURED, bluetooth characteristics have not been set\n  - IDLE, state machine is ready for use\n  - TRANSFERING, state machine is i the process of updating a device\n  - COMPLETE, indicates that a device update has been completed\n  - FAILED, device update failed\n**/\nconst StateMachineStates = {\n  NOT_CONFIGURED: 0x00,\n  IDLE: 0x01,\n  TRANSFERING: 0x02,\n  COMPLETE: 0x03,\n  FAILED: 0x04\n}\n\n/**\nMain Facade class to the library\n  Create StateMachine with WebBluetoothCharacteristics representing the data and control point\n  Monitor the state property and use the function sendFirmware() to send a DFU zip.\n**/\nclass StateMachine {\n\n  constructor (webBluetoothControlPoint, webBluetoothPacketPoint) {\n    this._state = StateMachineStates.NOT_CONFIGURED\n    Object.defineProperty(this,\"state\",{\n      get: function () {\n        return this._state\n      },\n      set: function (value) {\n        this._state = value\n        if (this.delegate !== undefined) {\n          this.delegate.updateStateMachine()\n        }\n      },\n      configurable: true\n    })\n    this.setControlPoint(webBluetoothControlPoint)\n    this.setPacketPoint(webBluetoothPacketPoint)\n    /** TODO: The queue should have better error reporting which are tied to state */\n    this.fileTransfers = queue(TransferWorker, 1)\n    if (this.controlpointCharacteristic && this.packetCharacteristic) {\n      this.state = StateMachineStates.IDLE\n    }\n  }\n/*\n  constructor (webBluetoothControlPoint, webBluetoothPacketPoint) {\n    this.state = StateMachineStates.NOT_CONFIGURED\n    this.setControlPoint(webBluetoothControlPoint)\n    this.setPacketPoint(webBluetoothPacketPoint)\n    this.fileTransfers = queue(TransferWorker, 1)\n    if (this.controlpointCharacteristic && this.packetCharacteristic) {\n      this.state = StateMachineStates.IDLE\n    }\n  }\n*/\n  setDelegate (delegate) {\n    this.delegate = delegate\n  }\n\n  setControlPoint (webBluetoothCharacteristic) {\n    this.controlpointCharacteristic = webBluetoothCharacteristic\n    if (this.state === StateMachineStates.NOT_CONFIGURED && this.controlpointCharacteristic !== undefined && this.packetCharacteristic !== undefined) {\n      this.state = StateMachineStates.IDLE\n    }\n  }\n\n  setPacketPoint (webBluetoothCharacteristic) {\n    this.packetCharacteristic = webBluetoothCharacteristic\n    if (this.state === StateMachineStates.NOT_CONFIGURED && this.controlpointCharacteristic !== undefined && this.packetCharacteristic !== undefined) {\n      this.state = StateMachineStates.IDLE\n    }\n  }\n\n  progress () {\n    switch (this.state) {\n      case StateMachineStates.NOT_CONFIGURED:\n        return 0.0\n      case StateMachineStates.IDLE:\n        return 0.0\n      case StateMachineStates.COMPLETE:\n        return 1.0\n      case StateMachineStates.FAILED:\n        return 1.0\n      case StateMachineStates.TRANSFERING:\n        if (CurrentTransfer !== undefined) {\n          return CurrentTransfer.progress()\n        } else {\n          console.error('DFU StateMachine is in State Transfering but no transfer is set')\n          return 0.0\n        }\n    }\n  }\n  /**\n    Internal method used to slot each part of a dfu zip for transfer to device\n  **/\n  addTransfer (transfer) {\n    this.fileTransfers.push(transfer, (error) => {\n      if (error) {\n        this.fileTransfers.kill()\n      }\n    })\n  }\n\n  /**\n    Send a firmware to a device. Throws when parameter or state is invalid for sending a firmware\n  **/\n  sendFirmware (firmware) {\n    if (this.state === StateMachineStates.NOT_CONFIGURED) {\n      throw new Error('StateMachine is not configured with bluetooth characteristics')\n    }\n    if (this.state !== StateMachineStates.IDLE) {\n      throw new Error('Can only initate transfer when idle')\n    }\n    if (firmware instanceof Firmware === false) {\n      throw new Error('Firmware needs to be of class Firmware')\n    }\n    for(var section of firmware.sections) {\n      this.addTransfer(new Transfer(section.dat, this.controlpointCharacteristic, this.packetCharacteristic, TransferObjectType.Command))\n      this.addTransfer(new Transfer(section.bin, this.controlpointCharacteristic, this.packetCharacteristic, TransferObjectType.Data))\n    }\n  }\n\n}\n\nmodule.exports.States = StateMachineStates\nmodule.exports.StateMachine = StateMachine\n"]}